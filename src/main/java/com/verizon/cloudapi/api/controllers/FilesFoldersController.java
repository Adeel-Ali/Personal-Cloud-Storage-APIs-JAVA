/*
 * PersonalCloudStorageAPIsLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 10/10/2016
 */
package com.verizon.cloudapi.api.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import com.verizon.cloudapi.api.*;
import com.verizon.cloudapi.api.models.*;
import com.verizon.cloudapi.api.exceptions.*;
import com.verizon.cloudapi.api.http.client.HttpClient;
import com.verizon.cloudapi.api.http.client.HttpContext;
import com.verizon.cloudapi.api.http.request.HttpRequest;
import com.verizon.cloudapi.api.http.response.HttpResponse;
import com.verizon.cloudapi.api.http.response.HttpStringResponse;
import com.verizon.cloudapi.api.http.client.APICallBack;
import com.verizon.cloudapi.api.controllers.syncwrapper.APICallBackCatcher;

public class FilesFoldersController extends BaseController {    
    //private static variables for the singleton pattern
    private static Object syncObject = new Object();
    private static FilesFoldersController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the FilesFoldersController class 
     */
    public static FilesFoldersController getInstance() {
        synchronized (syncObject) {
            if (null == instance) {
                instance = new FilesFoldersController();
            }
        }
        return instance;
    }

    /**
     * Restores files or folders.
     * @param    trashcanItems    Required parameter: Request object to restore files or folders from trash.
     * @return    Returns the DynamicResponse response from the API call 
     */
    public DynamicResponse createRestoreTrash(
                final DeletedList trashcanItems
    ) throws Throwable {
        APICallBackCatcher<DynamicResponse> callback = new APICallBackCatcher<DynamicResponse>();
        createRestoreTrashAsync(trashcanItems, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Restores files or folders.
     * @param    trashcanItems    Required parameter: Request object to restore files or folders from trash.
     * @return    Returns the void response from the API call 
     */
    public void createRestoreTrashAsync(
                final DeletedList trashcanItems,
                final APICallBack<DynamicResponse> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/restore");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5542666048885131067L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(trashcanItems));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Path is invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] Resource not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            DynamicResponse _result = new DynamicResponse(_response);

                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieve information on all file and folder content.
     * @param    virtualfolder    Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    xHeaderETag    Optional parameter: Omit this header to request a full response.  To request only changes since a previous call to fullview, include this header as copied from your previous /fullview response.
     * @return    Returns the FullviewResponse response from the API call 
     */
    public FullviewResponse getFullview(
                final String virtualfolder,
                final String xHeaderETag
    ) throws Throwable {
        APICallBackCatcher<FullviewResponse> callback = new APICallBackCatcher<FullviewResponse>();
        getFullviewAsync(virtualfolder, xHeaderETag, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieve information on all file and folder content.
     * @param    virtualfolder    Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    xHeaderETag    Optional parameter: Omit this header to request a full response.  To request only changes since a previous call to fullview, include this header as copied from your previous /fullview response.
     * @return    Returns the void response from the API call 
     */
    public void getFullviewAsync(
                final String virtualfolder,
                final String xHeaderETag,
                final APICallBack<FullviewResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fullview");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5238958692162809296L;
            {
                    put( "virtualfolder", virtualfolder );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4911883642780165603L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "X-Header-ETag", xHeaderETag );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 412)
                                throw new ErrorResponseException("[Precondition Failed] An X-Header-ETag header was included in the request, and there are no changes to report.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            FullviewResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<FullviewResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieves file content.
     * @param    path    Required parameter: The path to the file or folder.
     * @return    Returns the DynamicResponse response from the API call 
     */
    public DynamicResponse getFiles(
                final String path
    ) throws Throwable {
        APICallBackCatcher<DynamicResponse> callback = new APICallBackCatcher<DynamicResponse>();
        getFilesAsync(path, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieves file content.
     * @param    path    Required parameter: The path to the file or folder.
     * @return    Returns the void response from the API call 
     */
    public void getFilesAsync(
                final String path,
                final APICallBack<DynamicResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/files/{path}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5119815735664114029L;
            {
                    put( "path", path );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4849580931394502243L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            DynamicResponse _result = new DynamicResponse(_response);

                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Rename a file/folder.
     * @param    fileRenameRequest    Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to rename a file/folder.
     * @return    Returns the MetadataResponse response from the API call 
     */
    public MetadataResponse postRename(
                final FopsChangeRequest fileRenameRequest
    ) throws Throwable {
        APICallBackCatcher<MetadataResponse> callback = new APICallBackCatcher<MetadataResponse>();
        postRenameAsync(fileRenameRequest, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Rename a file/folder.
     * @param    fileRenameRequest    Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to rename a file/folder.
     * @return    Returns the void response from the API call 
     */
    public void postRenameAsync(
                final FopsChangeRequest fileRenameRequest,
                final APICallBack<MetadataResponse> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/rename");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4692037581730825674L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(fileRenameRequest));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 409)
                                throw new ErrorResponseException("Conflict.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MetadataResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MetadataResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Move a file or folder.
     * @param    fileMoveRequest    Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to move a file/folder.
     * @return    Returns the MetadataResponse response from the API call 
     */
    public MetadataResponse postMove(
                final FopsChangeRequest fileMoveRequest
    ) throws Throwable {
        APICallBackCatcher<MetadataResponse> callback = new APICallBackCatcher<MetadataResponse>();
        postMoveAsync(fileMoveRequest, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Move a file or folder.
     * @param    fileMoveRequest    Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to move a file/folder.
     * @return    Returns the void response from the API call 
     */
    public void postMoveAsync(
                final FopsChangeRequest fileMoveRequest,
                final APICallBack<MetadataResponse> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/move");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5432077517669751132L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(fileMoveRequest));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 409)
                                throw new ErrorResponseException("Conflict.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MetadataResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MetadataResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Create a copy of a file/folder.
     * @param    fileCopyRequest    Required parameter: 'safe', 'conflictsolve' and 'override' are optional parameters in the request object to copy a file/folder.
     * @return    Returns the MetadataResponse response from the API call 
     */
    public MetadataResponse postCopy(
                final FopsCopyRequest fileCopyRequest
    ) throws Throwable {
        APICallBackCatcher<MetadataResponse> callback = new APICallBackCatcher<MetadataResponse>();
        postCopyAsync(fileCopyRequest, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Create a copy of a file/folder.
     * @param    fileCopyRequest    Required parameter: 'safe', 'conflictsolve' and 'override' are optional parameters in the request object to copy a file/folder.
     * @return    Returns the void response from the API call 
     */
    public void postCopyAsync(
                final FopsCopyRequest fileCopyRequest,
                final APICallBack<MetadataResponse> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/copy");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4663622463086515962L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(fileCopyRequest));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 409)
                                throw new ErrorResponseException("Conflict.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MetadataResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MetadataResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Delete a file/folder.
     * @param    path    Required parameter: Full path of the file/folder to be deleted.
     * @param    purge    Optional parameter: If 'true', permanently deletes the file/folder.
     * @return    Returns the void response from the API call 
     */
    public void deleteDelete(
                final String path,
                final Boolean purge
    ) throws Throwable {
        APICallBackCatcher<Object> callback = new APICallBackCatcher<Object>();
        deleteDeleteAsync(path, purge, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        callback.getResult();
    }

    /**
     * Delete a file/folder.
     * @param    path    Required parameter: Full path of the file/folder to be deleted.
     * @param    purge    Optional parameter: If 'true', permanently deletes the file/folder.
     * @return    Returns the void response from the API call 
     */
    public void deleteDeleteAsync(
                final String path,
                final Boolean purge,
                final APICallBack<Object> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/delete");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5592600530130781124L;
            {
                    put( "path", path );
                    put( "purge", (null != purge) ? purge : false );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5752397782053989547L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().delete(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //let the caller know of the success
                            callBack.onSuccess(_context, _context);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Create a folder.
     * @param    folder    Required parameter: 'override' is an optional parameter in the request object to create a folder.
     * @return    Returns the FolderMetadata response from the API call 
     */
    public FolderMetadata postCreatefolder(
                final FolderRequest folder
    ) throws Throwable {
        APICallBackCatcher<FolderMetadata> callback = new APICallBackCatcher<FolderMetadata>();
        postCreatefolderAsync(folder, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Create a folder.
     * @param    folder    Required parameter: 'override' is an optional parameter in the request object to create a folder.
     * @return    Returns the void response from the API call 
     */
    public void postCreatefolderAsync(
                final FolderRequest folder,
                final APICallBack<FolderMetadata> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fops/createfolder");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5128906608957338242L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(folder));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] Path was not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            FolderMetadata _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<FolderMetadata>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Completes chunk file upload.
     * @param    uploadid    Required parameter: Unique id to upload file binary content and to create the file. Uploadid is obtained via a call to the /fileupload/intent API (it is embedded in the URLs included in the response).
     * @return    Returns the FileMetadata response from the API call 
     */
    public FileMetadata uploadFileCreate(
                final String uploadid
    ) throws Throwable {
        APICallBackCatcher<FileMetadata> callback = new APICallBackCatcher<FileMetadata>();
        uploadFileCreateAsync(uploadid, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Completes chunk file upload.
     * @param    uploadid    Required parameter: Unique id to upload file binary content and to create the file. Uploadid is obtained via a call to the /fileupload/intent API (it is embedded in the URLs included in the response).
     * @return    Returns the void response from the API call 
     */
    public void uploadFileCreateAsync(
                final String uploadid,
                final APICallBack<FileMetadata> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/commit/{uploadid}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4638343824990366718L;
            {
                    put( "uploadid", uploadid );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4714318083634658372L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().post(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            FileMetadata _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<FileMetadata>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieves a list of deleted files and folders from a single user repository.
     * @param    virtualfolder    Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    sort    Optional parameter: Controls the sort order in which the response is returned. Uses the syntax: sort={field}+(asc|desc).
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @param    deep    Optional parameter: Specifies whether the search should stop at the topmost deleted item in the tree (deep=false), or navigate into it and list all the deleted contents    (deep=true).
     * @return    Returns the TrashResponse response from the API call 
     */
    public TrashResponse retrieveTrash(
                final String virtualfolder,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter,
                final Boolean deep
    ) throws Throwable {
        APICallBackCatcher<TrashResponse> callback = new APICallBackCatcher<TrashResponse>();
        retrieveTrashAsync(virtualfolder, sort, start, count, filter, deep, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieves a list of deleted files and folders from a single user repository.
     * @param    virtualfolder    Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    sort    Optional parameter: Controls the sort order in which the response is returned. Uses the syntax: sort={field}+(asc|desc).
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @param    deep    Optional parameter: Specifies whether the search should stop at the topmost deleted item in the tree (deep=false), or navigate into it and list all the deleted contents    (deep=true).
     * @return    Returns the void response from the API call 
     */
    public void retrieveTrashAsync(
                final String virtualfolder,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter,
                final Boolean deep,
                final APICallBack<TrashResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/trash");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5627462175689274371L;
            {
                    put( "virtualfolder", virtualfolder );
                    put( "sort", sort );
                    put( "start", start );
                    put( "count", count );
                    put( "filter", filter );
                    put( "deep", (null != deep) ? deep : false );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5304867099445496544L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] Resource not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            TrashResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<TrashResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Search for files and folders.
     * @param    query    Required parameter: Contains the text to be searched and supports a number of query fields that allow clients to restrict the search to particular parts of a file's or folder's metadata
     * @param    virtualfolder    Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Page number to return, for paginated responses. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @return    Returns the SearchresultResponse response from the API call 
     */
    public SearchresultResponse getSearch(
                final String query,
                final String virtualfolder,
                final String sort,
                final Integer start,
                final Integer count
    ) throws Throwable {
        APICallBackCatcher<SearchresultResponse> callback = new APICallBackCatcher<SearchresultResponse>();
        getSearchAsync(query, virtualfolder, sort, start, count, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Search for files and folders.
     * @param    query    Required parameter: Contains the text to be searched and supports a number of query fields that allow clients to restrict the search to particular parts of a file's or folder's metadata
     * @param    virtualfolder    Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Page number to return, for paginated responses. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @return    Returns the void response from the API call 
     */
    public void getSearchAsync(
                final String query,
                final String virtualfolder,
                final String sort,
                final Integer start,
                final Integer count,
                final APICallBack<SearchresultResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/search");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4935877933411053092L;
            {
                    put( "query", query );
                    put( "virtualfolder", virtualfolder );
                    put( "sort", sort );
                    put( "start", start );
                    put( "count", count );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5711689082139464460L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            SearchresultResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<SearchresultResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Retrieve thumbnails for a file.
     * @param    contentToken    Required parameter: The file's content token (obtained from a call to /metadata or /fullview).
     * @param    size    Required parameter: Thumbnail size: 'xs' (24x24), 's' (64x64), or 'm' (128x128). Either 'size' or 'th' and 'tw' are required.
     * @param    th    Required parameter: Thumbnail height (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @param    tw    Required parameter: Thumbnail width (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @return    Returns the DynamicResponse response from the API call 
     */
    public DynamicResponse getThumbnails(
                final String contentToken,
                final String size,
                final int th,
                final int tw
    ) throws Throwable {
        APICallBackCatcher<DynamicResponse> callback = new APICallBackCatcher<DynamicResponse>();
        getThumbnailsAsync(contentToken, size, th, tw, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Retrieve thumbnails for a file.
     * @param    contentToken    Required parameter: The file's content token (obtained from a call to /metadata or /fullview).
     * @param    size    Required parameter: Thumbnail size: 'xs' (24x24), 's' (64x64), or 'm' (128x128). Either 'size' or 'th' and 'tw' are required.
     * @param    th    Required parameter: Thumbnail height (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @param    tw    Required parameter: Thumbnail width (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @return    Returns the void response from the API call 
     */
    public void getThumbnailsAsync(
                final String contentToken,
                final String size,
                final int th,
                final int tw,
                final APICallBack<DynamicResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/thumbnails/{content-token}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4840716805931676837L;
            {
                    put( "content-token", contentToken );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5078736916053597457L;
            {
                    put( "size", size );
                    put( "th", th );
                    put( "tw", tw );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5694735145728417003L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 415)
                                throw new ErrorResponseException("[Unsupported Media Type] Thumbnails are not supported for this type of file.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            DynamicResponse _result = new DynamicResponse(_response);

                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get metadata for a file or folder in a user's repository.
     * @param    path    Required parameter: The path to the file or folder.
     * @param    includeDeleted    Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return    Returns the MetadataResponse response from the API call 
     */
    public MetadataResponse getMetadataPath(
                final String path,
                final Boolean includeDeleted,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter
    ) throws Throwable {
        APICallBackCatcher<MetadataResponse> callback = new APICallBackCatcher<MetadataResponse>();
        getMetadataPathAsync(path, includeDeleted, sort, start, count, filter, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get metadata for a file or folder in a user's repository.
     * @param    path    Required parameter: The path to the file or folder.
     * @param    includeDeleted    Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return    Returns the void response from the API call 
     */
    public void getMetadataPathAsync(
                final String path,
                final Boolean includeDeleted,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter,
                final APICallBack<MetadataResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/metadata/{path}");

        //process template parameters
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4876265217640289172L;
            {
                    put( "path", path );
            }});

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4931731151604804043L;
            {
                    put( "include_deleted", (null != includeDeleted) ? includeDeleted : false );
                    put( "sort", sort );
                    put( "start", start );
                    put( "count", count );
                    put( "filter", filter );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4814667482040245282L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 410)
                                throw new ErrorResponseException("[Gone] File was removed.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MetadataResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MetadataResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Purges all the files and folder from a repository.
     * @param    virtualfolder    Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @return    Returns the void response from the API call 
     */
    public void deletePurgeTrash(
                final String virtualfolder
    ) throws Throwable {
        APICallBackCatcher<Object> callback = new APICallBackCatcher<Object>();
        deletePurgeTrashAsync(virtualfolder, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        callback.getResult();
    }

    /**
     * Purges all the files and folder from a repository.
     * @param    virtualfolder    Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @return    Returns the void response from the API call 
     */
    public void deletePurgeTrashAsync(
                final String virtualfolder,
                final APICallBack<Object> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/trash");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5084842176651895024L;
            {
                    put( "virtualfolder", virtualfolder );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4907489904380236759L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().delete(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request]", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //let the caller know of the success
                            callBack.onSuccess(_context, _context);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get metadata for the root folder contents.
     * @param    includeDeleted    Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return    Returns the MetadataResponse response from the API call 
     */
    public MetadataResponse getMetadata(
                final Boolean includeDeleted,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter
    ) throws Throwable {
        APICallBackCatcher<MetadataResponse> callback = new APICallBackCatcher<MetadataResponse>();
        getMetadataAsync(includeDeleted, sort, start, count, filter, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get metadata for the root folder contents.
     * @param    includeDeleted    Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param    sort    Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param    start    Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param    count    Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param    filter    Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return    Returns the void response from the API call 
     */
    public void getMetadataAsync(
                final Boolean includeDeleted,
                final String sort,
                final Integer start,
                final Integer count,
                final String filter,
                final APICallBack<MetadataResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/metadata");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5313453563981385037L;
            {
                    put( "include_deleted", (null != includeDeleted) ? includeDeleted : false );
                    put( "sort", sort );
                    put( "start", start );
                    put( "count", count );
                    put( "filter", filter );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5516498497255650485L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 404)
                                throw new ErrorResponseException("[Not Found] File was not found.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MetadataResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MetadataResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Initiates a file upload intent request.
     * @param    path    Required parameter: The path to the folder where file has to be uploaded.
     * @param    name    Required parameter: Name of the file to be uploaded.
     * @param    size    Required parameter: Size of the file to be uploaded.
     * @param    checksum    Required parameter: Checksum of the file/chunk.
     * @param    chunk    Optional parameter: Should be set to false, in case the file binary has to be uploaded with single request. Otherwise should be set to true when file binary has to be uploaded in multiple request.
     * @return    Returns the Uploadurls response from the API call 
     */
    public Uploadurls getUploadFileIntent(
                final String path,
                final String name,
                final int size,
                final String checksum,
                final Boolean chunk
    ) throws Throwable {
        APICallBackCatcher<Uploadurls> callback = new APICallBackCatcher<Uploadurls>();
        getUploadFileIntentAsync(path, name, size, checksum, chunk, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Initiates a file upload intent request.
     * @param    path    Required parameter: The path to the folder where file has to be uploaded.
     * @param    name    Required parameter: Name of the file to be uploaded.
     * @param    size    Required parameter: Size of the file to be uploaded.
     * @param    checksum    Required parameter: Checksum of the file/chunk.
     * @param    chunk    Optional parameter: Should be set to false, in case the file binary has to be uploaded with single request. Otherwise should be set to true when file binary has to be uploaded in multiple request.
     * @return    Returns the void response from the API call 
     */
    public void getUploadFileIntentAsync(
                final String path,
                final String name,
                final int size,
                final String checksum,
                final Boolean chunk,
                final APICallBack<Uploadurls> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/fileupload/intent");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4963399058740386520L;
            {
                    put( "path", path );
                    put( "name", name );
                    put( "size", size );
                    put( "checksum", checksum );
                    put( "chunk", (null != chunk) ? chunk : false );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5366403776213659023L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
                    put( "Authorization", String.format("Bearer %1$s", Configuration.oAuthAccessToken) );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //Error handling using HTTP status codes
                            int _responseCode = _response.getStatusCode();
                            if (_responseCode == 400)
                                throw new ErrorResponseException("[Bad Request] Query parameters missing or invalid.", _context);

                            else if (_responseCode == 401)
                                throw new ErrorResponseException("[Unauthorized] Bearer token is missing, expired, or invalid.", _context);

                            else if (_responseCode == 413)
                                throw new ErrorResponseException("[Request Too Long] User quota exceeded.", _context);

                            else if (_responseCode == 503)
                                throw new ErrorResponseException("[Service Unavailable] See response body for more detail.", _context);

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            Uploadurls _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<Uploadurls>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

}